// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_IVEF_2eproto__INCLUDED
#define PROTOBUF_IVEF_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

class IVEFSchema;
class IVEFHeader;
class IVEFMSG_VesselData;
class IVEFBody;
class IVEFVesselData;
class IVEFPosReport;
class IVEFStaticData;
class IVEFVoyage;
class IVEFMSG_LoginRequest;
class IVEFLoginRequest;
class IVEFMSG_LoginResponse;
class IVEFLoginResponse;
class IVEFMSG_Ping;
class IVEFPing;
class IVEFMSG_Pong;
class IVEFPong;
class IVEFMSG_ServerStatus;
class IVEFServerStatus;
class IVEFMSG_Logout;
class IVEFLogout;
class IVEFMSG_ServiceRequest;
class IVEFServiceRequest;
class IVEFArea;
class IVEFTransmission;
class IVEFItem;
class IVEFObject;
class IVEFPos;

// ===================================================================

class IVEFSchema : public ::google::protobuf::Message {
 public:
  IVEFSchema();
  virtual ~IVEFSchema();
  
  IVEFSchema(const IVEFSchema& from);
  
  inline IVEFSchema& operator=(const IVEFSchema& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFSchema& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFSchema* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string elementFormDefault = 1;
  inline bool has_elementformdefault() const;
  inline void clear_elementformdefault();
  inline const ::std::string& elementformdefault() const;
  inline void set_elementformdefault(const ::std::string& value);
  inline void set_elementformdefault(const char* value);
  inline ::std::string* mutable_elementformdefault();
  
  // required string targetNamespace = 2;
  inline bool has_targetnamespace() const;
  inline void clear_targetnamespace();
  inline const ::std::string& targetnamespace() const;
  inline void set_targetnamespace(const ::std::string& value);
  inline void set_targetnamespace(const char* value);
  inline ::std::string* mutable_targetnamespace();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* elementformdefault_;
  static const ::std::string _default_elementformdefault_;
  ::std::string* targetnamespace_;
  static const ::std::string _default_targetnamespace_;
  
  static const IVEFSchema default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFHeader : public ::google::protobuf::Message {
 public:
  IVEFHeader();
  virtual ~IVEFHeader();
  
  IVEFHeader(const IVEFHeader& from);
  
  inline IVEFHeader& operator=(const IVEFHeader& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFHeader& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFHeader* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline ::std::string* mutable_version();
  
  // required string msgRefId = 2;
  inline bool has_msgrefid() const;
  inline void clear_msgrefid();
  inline const ::std::string& msgrefid() const;
  inline void set_msgrefid(const ::std::string& value);
  inline void set_msgrefid(const char* value);
  inline ::std::string* mutable_msgrefid();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* version_;
  static const ::std::string _default_version_;
  ::std::string* msgrefid_;
  static const ::std::string _default_msgrefid_;
  
  static const IVEFHeader default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFMSG_VesselData : public ::google::protobuf::Message {
 public:
  IVEFMSG_VesselData();
  virtual ~IVEFMSG_VesselData();
  
  IVEFMSG_VesselData(const IVEFMSG_VesselData& from);
  
  inline IVEFMSG_VesselData& operator=(const IVEFMSG_VesselData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFMSG_VesselData& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFMSG_VesselData* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .IVEFHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  inline const ::IVEFHeader& header() const;
  inline ::IVEFHeader* mutable_header();
  
  // required .IVEFBody body = 2;
  inline bool has_body() const;
  inline void clear_body();
  inline const ::IVEFBody& body() const;
  inline ::IVEFBody* mutable_body();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::IVEFHeader* header_;
  ::IVEFBody* body_;
  
  static const IVEFMSG_VesselData default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFBody : public ::google::protobuf::Message {
 public:
  IVEFBody();
  virtual ~IVEFBody();
  
  IVEFBody(const IVEFBody& from);
  
  inline IVEFBody& operator=(const IVEFBody& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFBody& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFBody* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .IVEFVesselData vesselData = 1;
  inline int vesseldata_size() const;
  inline void clear_vesseldata();
  inline const ::google::protobuf::RepeatedPtrField< ::IVEFVesselData >& vesseldata() const;
  inline ::google::protobuf::RepeatedPtrField< ::IVEFVesselData >* mutable_vesseldata();
  inline const ::IVEFVesselData& vesseldata(int index) const;
  inline ::IVEFVesselData* mutable_vesseldata(int index);
  inline ::IVEFVesselData* add_vesseldata();
  
  // optional .IVEFLoginRequest loginRequest = 2;
  inline bool has_loginrequest() const;
  inline void clear_loginrequest();
  inline const ::IVEFLoginRequest& loginrequest() const;
  inline ::IVEFLoginRequest* mutable_loginrequest();
  
  // optional .IVEFLoginResponse loginResponse = 3;
  inline bool has_loginresponse() const;
  inline void clear_loginresponse();
  inline const ::IVEFLoginResponse& loginresponse() const;
  inline ::IVEFLoginResponse* mutable_loginresponse();
  
  // optional .IVEFPing ping = 4;
  inline bool has_ping() const;
  inline void clear_ping();
  inline const ::IVEFPing& ping() const;
  inline ::IVEFPing* mutable_ping();
  
  // optional .IVEFPong pong = 5;
  inline bool has_pong() const;
  inline void clear_pong();
  inline const ::IVEFPong& pong() const;
  inline ::IVEFPong* mutable_pong();
  
  // optional .IVEFServerStatus serverStatus = 6;
  inline bool has_serverstatus() const;
  inline void clear_serverstatus();
  inline const ::IVEFServerStatus& serverstatus() const;
  inline ::IVEFServerStatus* mutable_serverstatus();
  
  // optional .IVEFLogout logout = 7;
  inline bool has_logout() const;
  inline void clear_logout();
  inline const ::IVEFLogout& logout() const;
  inline ::IVEFLogout* mutable_logout();
  
  // optional .IVEFServiceRequest serviceRequest = 8;
  inline bool has_servicerequest() const;
  inline void clear_servicerequest();
  inline const ::IVEFServiceRequest& servicerequest() const;
  inline ::IVEFServiceRequest* mutable_servicerequest();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::IVEFVesselData > vesseldata_;
  ::IVEFLoginRequest* loginrequest_;
  ::IVEFLoginResponse* loginresponse_;
  ::IVEFPing* ping_;
  ::IVEFPong* pong_;
  ::IVEFServerStatus* serverstatus_;
  ::IVEFLogout* logout_;
  ::IVEFServiceRequest* servicerequest_;
  
  static const IVEFBody default_instance_;
  static const int _offsets_[8];
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFVesselData : public ::google::protobuf::Message {
 public:
  IVEFVesselData();
  virtual ~IVEFVesselData();
  
  IVEFVesselData(const IVEFVesselData& from);
  
  inline IVEFVesselData& operator=(const IVEFVesselData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFVesselData& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFVesselData* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .IVEFPosReport posReport = 1;
  inline bool has_posreport() const;
  inline void clear_posreport();
  inline const ::IVEFPosReport& posreport() const;
  inline ::IVEFPosReport* mutable_posreport();
  
  // repeated .IVEFStaticData staticData = 2;
  inline int staticdata_size() const;
  inline void clear_staticdata();
  inline const ::google::protobuf::RepeatedPtrField< ::IVEFStaticData >& staticdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::IVEFStaticData >* mutable_staticdata();
  inline const ::IVEFStaticData& staticdata(int index) const;
  inline ::IVEFStaticData* mutable_staticdata(int index);
  inline ::IVEFStaticData* add_staticdata();
  
  // repeated .IVEFVoyage voyage = 3;
  inline int voyage_size() const;
  inline void clear_voyage();
  inline const ::google::protobuf::RepeatedPtrField< ::IVEFVoyage >& voyage() const;
  inline ::google::protobuf::RepeatedPtrField< ::IVEFVoyage >* mutable_voyage();
  inline const ::IVEFVoyage& voyage(int index) const;
  inline ::IVEFVoyage* mutable_voyage(int index);
  inline ::IVEFVoyage* add_voyage();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::IVEFPosReport* posreport_;
  ::google::protobuf::RepeatedPtrField< ::IVEFStaticData > staticdata_;
  ::google::protobuf::RepeatedPtrField< ::IVEFVoyage > voyage_;
  
  static const IVEFVesselData default_instance_;
  static const int _offsets_[3];
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFPosReport : public ::google::protobuf::Message {
 public:
  IVEFPosReport();
  virtual ~IVEFPosReport();
  
  IVEFPosReport(const IVEFPosReport& from);
  
  inline IVEFPosReport& operator=(const IVEFPosReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFPosReport& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFPosReport* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .IVEFPos pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  inline const ::IVEFPos& pos() const;
  inline ::IVEFPos* mutable_pos();
  
  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required int32 sourceId = 3;
  inline bool has_sourceid() const;
  inline void clear_sourceid();
  inline ::google::protobuf::int32 sourceid() const;
  inline void set_sourceid(::google::protobuf::int32 value);
  
  // required string updateTime = 4;
  inline bool has_updatetime() const;
  inline void clear_updatetime();
  inline const ::std::string& updatetime() const;
  inline void set_updatetime(const ::std::string& value);
  inline void set_updatetime(const char* value);
  inline ::std::string* mutable_updatetime();
  
  // required float SOG = 5;
  inline bool has_sog() const;
  inline void clear_sog();
  inline float sog() const;
  inline void set_sog(float value);
  
  // required float COG = 6;
  inline bool has_cog() const;
  inline void clear_cog();
  inline float cog() const;
  inline void set_cog(float value);
  
  // required string lost = 7;
  inline bool has_lost() const;
  inline void clear_lost();
  inline const ::std::string& lost() const;
  inline void set_lost(const ::std::string& value);
  inline void set_lost(const char* value);
  inline ::std::string* mutable_lost();
  
  // optional float rateOfTurn = 8;
  inline bool has_rateofturn() const;
  inline void clear_rateofturn();
  inline float rateofturn() const;
  inline void set_rateofturn(float value);
  
  // optional float orientation = 9;
  inline bool has_orientation() const;
  inline void clear_orientation();
  inline float orientation() const;
  inline void set_orientation(float value);
  
  // optional float length = 10;
  inline bool has_length() const;
  inline void clear_length();
  inline float length() const;
  inline void set_length(float value);
  
  // optional float breadth = 11;
  inline bool has_breadth() const;
  inline void clear_breadth();
  inline float breadth() const;
  inline void set_breadth(float value);
  
  // optional float altitude = 12;
  inline bool has_altitude() const;
  inline void clear_altitude();
  inline float altitude() const;
  inline void set_altitude(float value);
  
  // optional int32 navStatus = 13;
  inline bool has_navstatus() const;
  inline void clear_navstatus();
  inline ::google::protobuf::int32 navstatus() const;
  inline void set_navstatus(::google::protobuf::int32 value);
  
  // optional int32 updSensorType = 14;
  inline bool has_updsensortype() const;
  inline void clear_updsensortype();
  inline ::google::protobuf::int32 updsensortype() const;
  inline void set_updsensortype(::google::protobuf::int32 value);
  
  // optional bool ATONOffPos = 15;
  inline bool has_atonoffpos() const;
  inline void clear_atonoffpos();
  inline bool atonoffpos() const;
  inline void set_atonoffpos(bool value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::IVEFPos* pos_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 sourceid_;
  ::std::string* updatetime_;
  static const ::std::string _default_updatetime_;
  float sog_;
  float cog_;
  ::std::string* lost_;
  static const ::std::string _default_lost_;
  float rateofturn_;
  float orientation_;
  float length_;
  float breadth_;
  float altitude_;
  ::google::protobuf::int32 navstatus_;
  ::google::protobuf::int32 updsensortype_;
  bool atonoffpos_;
  
  static const IVEFPosReport default_instance_;
  static const int _offsets_[15];
  
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFStaticData : public ::google::protobuf::Message {
 public:
  IVEFStaticData();
  virtual ~IVEFStaticData();
  
  IVEFStaticData(const IVEFStaticData& from);
  
  inline IVEFStaticData& operator=(const IVEFStaticData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFStaticData& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFStaticData* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required string sourceName = 2;
  inline bool has_sourcename() const;
  inline void clear_sourcename();
  inline const ::std::string& sourcename() const;
  inline void set_sourcename(const ::std::string& value);
  inline void set_sourcename(const char* value);
  inline ::std::string* mutable_sourcename();
  
  // required int32 source = 3;
  inline bool has_source() const;
  inline void clear_source();
  inline ::google::protobuf::int32 source() const;
  inline void set_source(::google::protobuf::int32 value);
  
  // optional float length = 4;
  inline bool has_length() const;
  inline void clear_length();
  inline float length() const;
  inline void set_length(float value);
  
  // optional float breadth = 5;
  inline bool has_breadth() const;
  inline void clear_breadth();
  inline float breadth() const;
  inline void set_breadth(float value);
  
  // optional string callsign = 6;
  inline bool has_callsign() const;
  inline void clear_callsign();
  inline const ::std::string& callsign() const;
  inline void set_callsign(const ::std::string& value);
  inline void set_callsign(const char* value);
  inline ::std::string* mutable_callsign();
  
  // optional string shipName = 7;
  inline bool has_shipname() const;
  inline void clear_shipname();
  inline const ::std::string& shipname() const;
  inline void set_shipname(const ::std::string& value);
  inline void set_shipname(const char* value);
  inline ::std::string* mutable_shipname();
  
  // optional int32 objectType = 8;
  inline bool has_objecttype() const;
  inline void clear_objecttype();
  inline ::google::protobuf::int32 objecttype() const;
  inline void set_objecttype(::google::protobuf::int32 value);
  
  // optional int32 shipType = 9;
  inline bool has_shiptype() const;
  inline void clear_shiptype();
  inline ::google::protobuf::int32 shiptype() const;
  inline void set_shiptype(::google::protobuf::int32 value);
  
  // optional int32 IMO = 10;
  inline bool has_imo() const;
  inline void clear_imo();
  inline ::google::protobuf::int32 imo() const;
  inline void set_imo(::google::protobuf::int32 value);
  
  // optional int32 MMSI = 11;
  inline bool has_mmsi() const;
  inline void clear_mmsi();
  inline ::google::protobuf::int32 mmsi() const;
  inline void set_mmsi(::google::protobuf::int32 value);
  
  // optional int32 ATONType = 12;
  inline bool has_atontype() const;
  inline void clear_atontype();
  inline ::google::protobuf::int32 atontype() const;
  inline void set_atontype(::google::protobuf::int32 value);
  
  // optional string ATONName = 13;
  inline bool has_atonname() const;
  inline void clear_atonname();
  inline const ::std::string& atonname() const;
  inline void set_atonname(const ::std::string& value);
  inline void set_atonname(const char* value);
  inline ::std::string* mutable_atonname();
  
  // optional float antPosDistFromFront = 14;
  inline bool has_antposdistfromfront() const;
  inline void clear_antposdistfromfront();
  inline float antposdistfromfront() const;
  inline void set_antposdistfromfront(float value);
  
  // optional float antPosDistFromLeft = 15;
  inline bool has_antposdistfromleft() const;
  inline void clear_antposdistfromleft();
  inline float antposdistfromleft() const;
  inline void set_antposdistfromleft(float value);
  
  // optional string natLangShipName = 16;
  inline bool has_natlangshipname() const;
  inline void clear_natlangshipname();
  inline const ::std::string& natlangshipname() const;
  inline void set_natlangshipname(const ::std::string& value);
  inline void set_natlangshipname(const char* value);
  inline ::std::string* mutable_natlangshipname();
  
  // optional string portOfRegistry = 17;
  inline bool has_portofregistry() const;
  inline void clear_portofregistry();
  inline const ::std::string& portofregistry() const;
  inline void set_portofregistry(const ::std::string& value);
  inline void set_portofregistry(const char* value);
  inline ::std::string* mutable_portofregistry();
  
  // optional string countryFlag = 18;
  inline bool has_countryflag() const;
  inline void clear_countryflag();
  inline const ::std::string& countryflag() const;
  inline void set_countryflag(const ::std::string& value);
  inline void set_countryflag(const char* value);
  inline ::std::string* mutable_countryflag();
  
  // optional float maxAirDraught = 19;
  inline bool has_maxairdraught() const;
  inline void clear_maxairdraught();
  inline float maxairdraught() const;
  inline void set_maxairdraught(float value);
  
  // optional float maxDraught = 20;
  inline bool has_maxdraught() const;
  inline void clear_maxdraught();
  inline float maxdraught() const;
  inline void set_maxdraught(float value);
  
  // optional string deepWaterVesselind = 21;
  inline bool has_deepwatervesselind() const;
  inline void clear_deepwatervesselind();
  inline const ::std::string& deepwatervesselind() const;
  inline void set_deepwatervesselind(const ::std::string& value);
  inline void set_deepwatervesselind(const char* value);
  inline ::std::string* mutable_deepwatervesselind();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::std::string* sourcename_;
  static const ::std::string _default_sourcename_;
  ::google::protobuf::int32 source_;
  float length_;
  float breadth_;
  ::std::string* callsign_;
  static const ::std::string _default_callsign_;
  ::std::string* shipname_;
  static const ::std::string _default_shipname_;
  ::google::protobuf::int32 objecttype_;
  ::google::protobuf::int32 shiptype_;
  ::google::protobuf::int32 imo_;
  ::google::protobuf::int32 mmsi_;
  ::google::protobuf::int32 atontype_;
  ::std::string* atonname_;
  static const ::std::string _default_atonname_;
  float antposdistfromfront_;
  float antposdistfromleft_;
  ::std::string* natlangshipname_;
  static const ::std::string _default_natlangshipname_;
  ::std::string* portofregistry_;
  static const ::std::string _default_portofregistry_;
  ::std::string* countryflag_;
  static const ::std::string _default_countryflag_;
  float maxairdraught_;
  float maxdraught_;
  ::std::string* deepwatervesselind_;
  static const ::std::string _default_deepwatervesselind_;
  
  static const IVEFStaticData default_instance_;
  static const int _offsets_[21];
  
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFVoyage : public ::google::protobuf::Message {
 public:
  IVEFVoyage();
  virtual ~IVEFVoyage();
  
  IVEFVoyage(const IVEFVoyage& from);
  
  inline IVEFVoyage& operator=(const IVEFVoyage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFVoyage& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFVoyage* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline ::std::string* mutable_id();
  
  // required string sourceName = 2;
  inline bool has_sourcename() const;
  inline void clear_sourcename();
  inline const ::std::string& sourcename() const;
  inline void set_sourcename(const ::std::string& value);
  inline void set_sourcename(const char* value);
  inline ::std::string* mutable_sourcename();
  
  // required int32 source = 3;
  inline bool has_source() const;
  inline void clear_source();
  inline ::google::protobuf::int32 source() const;
  inline void set_source(::google::protobuf::int32 value);
  
  // optional int32 cargoType = 4;
  inline bool has_cargotype() const;
  inline void clear_cargotype();
  inline ::google::protobuf::int32 cargotype() const;
  inline void set_cargotype(::google::protobuf::int32 value);
  
  // optional string destination = 5;
  inline bool has_destination() const;
  inline void clear_destination();
  inline const ::std::string& destination() const;
  inline void set_destination(const ::std::string& value);
  inline void set_destination(const char* value);
  inline ::std::string* mutable_destination();
  
  // optional string ETA = 6;
  inline bool has_eta() const;
  inline void clear_eta();
  inline const ::std::string& eta() const;
  inline void set_eta(const ::std::string& value);
  inline void set_eta(const char* value);
  inline ::std::string* mutable_eta();
  
  // optional string ATA = 7;
  inline bool has_ata() const;
  inline void clear_ata();
  inline const ::std::string& ata() const;
  inline void set_ata(const ::std::string& value);
  inline void set_ata(const char* value);
  inline ::std::string* mutable_ata();
  
  // optional float airDraught = 8;
  inline bool has_airdraught() const;
  inline void clear_airdraught();
  inline float airdraught() const;
  inline void set_airdraught(float value);
  
  // optional float draught = 9;
  inline bool has_draught() const;
  inline void clear_draught();
  inline float draught() const;
  inline void set_draught(float value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::std::string* sourcename_;
  static const ::std::string _default_sourcename_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 cargotype_;
  ::std::string* destination_;
  static const ::std::string _default_destination_;
  ::std::string* eta_;
  static const ::std::string _default_eta_;
  ::std::string* ata_;
  static const ::std::string _default_ata_;
  float airdraught_;
  float draught_;
  
  static const IVEFVoyage default_instance_;
  static const int _offsets_[9];
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFMSG_LoginRequest : public ::google::protobuf::Message {
 public:
  IVEFMSG_LoginRequest();
  virtual ~IVEFMSG_LoginRequest();
  
  IVEFMSG_LoginRequest(const IVEFMSG_LoginRequest& from);
  
  inline IVEFMSG_LoginRequest& operator=(const IVEFMSG_LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFMSG_LoginRequest& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFMSG_LoginRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .IVEFHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  inline const ::IVEFHeader& header() const;
  inline ::IVEFHeader* mutable_header();
  
  // required .IVEFBody body = 2;
  inline bool has_body() const;
  inline void clear_body();
  inline const ::IVEFBody& body() const;
  inline ::IVEFBody* mutable_body();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::IVEFHeader* header_;
  ::IVEFBody* body_;
  
  static const IVEFMSG_LoginRequest default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFLoginRequest : public ::google::protobuf::Message {
 public:
  IVEFLoginRequest();
  virtual ~IVEFLoginRequest();
  
  IVEFLoginRequest(const IVEFLoginRequest& from);
  
  inline IVEFLoginRequest& operator=(const IVEFLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFLoginRequest& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFLoginRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline ::std::string* mutable_name();
  
  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline ::std::string* mutable_password();
  
  // required int32 encryption = 3;
  inline bool has_encryption() const;
  inline void clear_encryption();
  inline ::google::protobuf::int32 encryption() const;
  inline void set_encryption(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* password_;
  static const ::std::string _default_password_;
  ::google::protobuf::int32 encryption_;
  
  static const IVEFLoginRequest default_instance_;
  static const int _offsets_[3];
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFMSG_LoginResponse : public ::google::protobuf::Message {
 public:
  IVEFMSG_LoginResponse();
  virtual ~IVEFMSG_LoginResponse();
  
  IVEFMSG_LoginResponse(const IVEFMSG_LoginResponse& from);
  
  inline IVEFMSG_LoginResponse& operator=(const IVEFMSG_LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFMSG_LoginResponse& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFMSG_LoginResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .IVEFHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  inline const ::IVEFHeader& header() const;
  inline ::IVEFHeader* mutable_header();
  
  // required .IVEFBody body = 2;
  inline bool has_body() const;
  inline void clear_body();
  inline const ::IVEFBody& body() const;
  inline ::IVEFBody* mutable_body();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::IVEFHeader* header_;
  ::IVEFBody* body_;
  
  static const IVEFMSG_LoginResponse default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFLoginResponse : public ::google::protobuf::Message {
 public:
  IVEFLoginResponse();
  virtual ~IVEFLoginResponse();
  
  IVEFLoginResponse(const IVEFLoginResponse& from);
  
  inline IVEFLoginResponse& operator=(const IVEFLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFLoginResponse& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFLoginResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string msgId = 1;
  inline bool has_msgid() const;
  inline void clear_msgid();
  inline const ::std::string& msgid() const;
  inline void set_msgid(const ::std::string& value);
  inline void set_msgid(const char* value);
  inline ::std::string* mutable_msgid();
  
  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional string reason = 3;
  inline bool has_reason() const;
  inline void clear_reason();
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline ::std::string* mutable_reason();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* msgid_;
  static const ::std::string _default_msgid_;
  ::google::protobuf::int32 result_;
  ::std::string* reason_;
  static const ::std::string _default_reason_;
  
  static const IVEFLoginResponse default_instance_;
  static const int _offsets_[3];
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFMSG_Ping : public ::google::protobuf::Message {
 public:
  IVEFMSG_Ping();
  virtual ~IVEFMSG_Ping();
  
  IVEFMSG_Ping(const IVEFMSG_Ping& from);
  
  inline IVEFMSG_Ping& operator=(const IVEFMSG_Ping& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFMSG_Ping& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFMSG_Ping* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .IVEFHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  inline const ::IVEFHeader& header() const;
  inline ::IVEFHeader* mutable_header();
  
  // required .IVEFBody body = 2;
  inline bool has_body() const;
  inline void clear_body();
  inline const ::IVEFBody& body() const;
  inline ::IVEFBody* mutable_body();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::IVEFHeader* header_;
  ::IVEFBody* body_;
  
  static const IVEFMSG_Ping default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFPing : public ::google::protobuf::Message {
 public:
  IVEFPing();
  virtual ~IVEFPing();
  
  IVEFPing(const IVEFPing& from);
  
  inline IVEFPing& operator=(const IVEFPing& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFPing& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFPing* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string timeStamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline ::std::string* mutable_timestamp();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* timestamp_;
  static const ::std::string _default_timestamp_;
  
  static const IVEFPing default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFMSG_Pong : public ::google::protobuf::Message {
 public:
  IVEFMSG_Pong();
  virtual ~IVEFMSG_Pong();
  
  IVEFMSG_Pong(const IVEFMSG_Pong& from);
  
  inline IVEFMSG_Pong& operator=(const IVEFMSG_Pong& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFMSG_Pong& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFMSG_Pong* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .IVEFHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  inline const ::IVEFHeader& header() const;
  inline ::IVEFHeader* mutable_header();
  
  // required .IVEFBody body = 2;
  inline bool has_body() const;
  inline void clear_body();
  inline const ::IVEFBody& body() const;
  inline ::IVEFBody* mutable_body();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::IVEFHeader* header_;
  ::IVEFBody* body_;
  
  static const IVEFMSG_Pong default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFPong : public ::google::protobuf::Message {
 public:
  IVEFPong();
  virtual ~IVEFPong();
  
  IVEFPong(const IVEFPong& from);
  
  inline IVEFPong& operator=(const IVEFPong& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFPong& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFPong* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string timeStamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline ::std::string* mutable_timestamp();
  
  // required string msgId = 2;
  inline bool has_msgid() const;
  inline void clear_msgid();
  inline const ::std::string& msgid() const;
  inline void set_msgid(const ::std::string& value);
  inline void set_msgid(const char* value);
  inline ::std::string* mutable_msgid();
  
  // required int32 sourceId = 3;
  inline bool has_sourceid() const;
  inline void clear_sourceid();
  inline ::google::protobuf::int32 sourceid() const;
  inline void set_sourceid(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* timestamp_;
  static const ::std::string _default_timestamp_;
  ::std::string* msgid_;
  static const ::std::string _default_msgid_;
  ::google::protobuf::int32 sourceid_;
  
  static const IVEFPong default_instance_;
  static const int _offsets_[3];
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFMSG_ServerStatus : public ::google::protobuf::Message {
 public:
  IVEFMSG_ServerStatus();
  virtual ~IVEFMSG_ServerStatus();
  
  IVEFMSG_ServerStatus(const IVEFMSG_ServerStatus& from);
  
  inline IVEFMSG_ServerStatus& operator=(const IVEFMSG_ServerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFMSG_ServerStatus& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFMSG_ServerStatus* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .IVEFHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  inline const ::IVEFHeader& header() const;
  inline ::IVEFHeader* mutable_header();
  
  // required .IVEFBody body = 2;
  inline bool has_body() const;
  inline void clear_body();
  inline const ::IVEFBody& body() const;
  inline ::IVEFBody* mutable_body();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::IVEFHeader* header_;
  ::IVEFBody* body_;
  
  static const IVEFMSG_ServerStatus default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFServerStatus : public ::google::protobuf::Message {
 public:
  IVEFServerStatus();
  virtual ~IVEFServerStatus();
  
  IVEFServerStatus(const IVEFServerStatus& from);
  
  inline IVEFServerStatus& operator=(const IVEFServerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFServerStatus& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFServerStatus* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string status = 1;
  inline bool has_status() const;
  inline void clear_status();
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline ::std::string* mutable_status();
  
  // optional string details = 2;
  inline bool has_details() const;
  inline void clear_details();
  inline const ::std::string& details() const;
  inline void set_details(const ::std::string& value);
  inline void set_details(const char* value);
  inline ::std::string* mutable_details();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* status_;
  static const ::std::string _default_status_;
  ::std::string* details_;
  static const ::std::string _default_details_;
  
  static const IVEFServerStatus default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFMSG_Logout : public ::google::protobuf::Message {
 public:
  IVEFMSG_Logout();
  virtual ~IVEFMSG_Logout();
  
  IVEFMSG_Logout(const IVEFMSG_Logout& from);
  
  inline IVEFMSG_Logout& operator=(const IVEFMSG_Logout& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFMSG_Logout& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFMSG_Logout* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .IVEFHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  inline const ::IVEFHeader& header() const;
  inline ::IVEFHeader* mutable_header();
  
  // required .IVEFBody body = 2;
  inline bool has_body() const;
  inline void clear_body();
  inline const ::IVEFBody& body() const;
  inline ::IVEFBody* mutable_body();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::IVEFHeader* header_;
  ::IVEFBody* body_;
  
  static const IVEFMSG_Logout default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFLogout : public ::google::protobuf::Message {
 public:
  IVEFLogout();
  virtual ~IVEFLogout();
  
  IVEFLogout(const IVEFLogout& from);
  
  inline IVEFLogout& operator=(const IVEFLogout& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFLogout& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFLogout* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  
  static const IVEFLogout default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFMSG_ServiceRequest : public ::google::protobuf::Message {
 public:
  IVEFMSG_ServiceRequest();
  virtual ~IVEFMSG_ServiceRequest();
  
  IVEFMSG_ServiceRequest(const IVEFMSG_ServiceRequest& from);
  
  inline IVEFMSG_ServiceRequest& operator=(const IVEFMSG_ServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFMSG_ServiceRequest& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFMSG_ServiceRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .IVEFHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  inline const ::IVEFHeader& header() const;
  inline ::IVEFHeader* mutable_header();
  
  // required .IVEFBody body = 2;
  inline bool has_body() const;
  inline void clear_body();
  inline const ::IVEFBody& body() const;
  inline ::IVEFBody* mutable_body();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::IVEFHeader* header_;
  ::IVEFBody* body_;
  
  static const IVEFMSG_ServiceRequest default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFServiceRequest : public ::google::protobuf::Message {
 public:
  IVEFServiceRequest();
  virtual ~IVEFServiceRequest();
  
  IVEFServiceRequest(const IVEFServiceRequest& from);
  
  inline IVEFServiceRequest& operator=(const IVEFServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFServiceRequest& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFServiceRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .IVEFArea area = 1;
  inline int area_size() const;
  inline void clear_area();
  inline const ::google::protobuf::RepeatedPtrField< ::IVEFArea >& area() const;
  inline ::google::protobuf::RepeatedPtrField< ::IVEFArea >* mutable_area();
  inline const ::IVEFArea& area(int index) const;
  inline ::IVEFArea* mutable_area(int index);
  inline ::IVEFArea* add_area();
  
  // required .IVEFTransmission transmission = 2;
  inline bool has_transmission() const;
  inline void clear_transmission();
  inline const ::IVEFTransmission& transmission() const;
  inline ::IVEFTransmission* mutable_transmission();
  
  // repeated .IVEFItem item = 3;
  inline int item_size() const;
  inline void clear_item();
  inline const ::google::protobuf::RepeatedPtrField< ::IVEFItem >& item() const;
  inline ::google::protobuf::RepeatedPtrField< ::IVEFItem >* mutable_item();
  inline const ::IVEFItem& item(int index) const;
  inline ::IVEFItem* mutable_item(int index);
  inline ::IVEFItem* add_item();
  
  // repeated .IVEFObject object = 4;
  inline int object_size() const;
  inline void clear_object();
  inline const ::google::protobuf::RepeatedPtrField< ::IVEFObject >& object() const;
  inline ::google::protobuf::RepeatedPtrField< ::IVEFObject >* mutable_object();
  inline const ::IVEFObject& object(int index) const;
  inline ::IVEFObject* mutable_object(int index);
  inline ::IVEFObject* add_object();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::IVEFArea > area_;
  ::IVEFTransmission* transmission_;
  ::google::protobuf::RepeatedPtrField< ::IVEFItem > item_;
  ::google::protobuf::RepeatedPtrField< ::IVEFObject > object_;
  
  static const IVEFServiceRequest default_instance_;
  static const int _offsets_[4];
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFArea : public ::google::protobuf::Message {
 public:
  IVEFArea();
  virtual ~IVEFArea();
  
  IVEFArea(const IVEFArea& from);
  
  inline IVEFArea& operator=(const IVEFArea& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFArea& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFArea* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .IVEFPos pos = 1;
  inline int pos_size() const;
  inline void clear_pos();
  inline const ::google::protobuf::RepeatedPtrField< ::IVEFPos >& pos() const;
  inline ::google::protobuf::RepeatedPtrField< ::IVEFPos >* mutable_pos();
  inline const ::IVEFPos& pos(int index) const;
  inline ::IVEFPos* mutable_pos(int index);
  inline ::IVEFPos* add_pos();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::IVEFPos > pos_;
  
  static const IVEFArea default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFTransmission : public ::google::protobuf::Message {
 public:
  IVEFTransmission();
  virtual ~IVEFTransmission();
  
  IVEFTransmission(const IVEFTransmission& from);
  
  inline IVEFTransmission& operator=(const IVEFTransmission& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFTransmission& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFTransmission* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional float period = 2;
  inline bool has_period() const;
  inline void clear_period();
  inline float period() const;
  inline void set_period(float value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 type_;
  float period_;
  
  static const IVEFTransmission default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFItem : public ::google::protobuf::Message {
 public:
  IVEFItem();
  virtual ~IVEFItem();
  
  IVEFItem(const IVEFItem& from);
  
  inline IVEFItem& operator=(const IVEFItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFItem& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFItem* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 element = 1;
  inline bool has_element() const;
  inline void clear_element();
  inline ::google::protobuf::int32 element() const;
  inline void set_element(::google::protobuf::int32 value);
  
  // required string field = 2;
  inline bool has_field() const;
  inline void clear_field();
  inline const ::std::string& field() const;
  inline void set_field(const ::std::string& value);
  inline void set_field(const char* value);
  inline ::std::string* mutable_field();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 element_;
  ::std::string* field_;
  static const ::std::string _default_field_;
  
  static const IVEFItem default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFObject : public ::google::protobuf::Message {
 public:
  IVEFObject();
  virtual ~IVEFObject();
  
  IVEFObject(const IVEFObject& from);
  
  inline IVEFObject& operator=(const IVEFObject& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFObject& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFObject* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string fileName = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline ::std::string* mutable_filename();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* filename_;
  static const ::std::string _default_filename_;
  
  static const IVEFObject default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IVEFPos : public ::google::protobuf::Message {
 public:
  IVEFPos();
  virtual ~IVEFPos();
  
  IVEFPos(const IVEFPos& from);
  
  inline IVEFPos& operator=(const IVEFPos& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IVEFPos& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IVEFPos* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  inline float lat() const;
  inline void set_lat(float value);
  
  // required float long = 2;
  inline bool has_long_() const;
  inline void clear_long_();
  inline float long_() const;
  inline void set_long_(float value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  float lat_;
  float long__;
  
  static const IVEFPos default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// ===================================================================


// ===================================================================


// ===================================================================

// IVEFSchema

// required string elementFormDefault = 1;
inline bool IVEFSchema::has_elementformdefault() const {
  return _has_bit(0);
}
inline void IVEFSchema::clear_elementformdefault() {
  if (elementformdefault_ != &_default_elementformdefault_) {
    elementformdefault_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& IVEFSchema::elementformdefault() const {
  return *elementformdefault_;
}
inline void IVEFSchema::set_elementformdefault(const ::std::string& value) {
  _set_bit(0);
  if (elementformdefault_ == &_default_elementformdefault_) {
    elementformdefault_ = new ::std::string;
  }
  elementformdefault_->assign(value);
}
inline void IVEFSchema::set_elementformdefault(const char* value) {
  _set_bit(0);
  if (elementformdefault_ == &_default_elementformdefault_) {
    elementformdefault_ = new ::std::string;
  }
  elementformdefault_->assign(value);
}
inline ::std::string* IVEFSchema::mutable_elementformdefault() {
  _set_bit(0);
  if (elementformdefault_ == &_default_elementformdefault_) {
    elementformdefault_ = new ::std::string;
  }
  return elementformdefault_;
}

// required string targetNamespace = 2;
inline bool IVEFSchema::has_targetnamespace() const {
  return _has_bit(1);
}
inline void IVEFSchema::clear_targetnamespace() {
  if (targetnamespace_ != &_default_targetnamespace_) {
    targetnamespace_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& IVEFSchema::targetnamespace() const {
  return *targetnamespace_;
}
inline void IVEFSchema::set_targetnamespace(const ::std::string& value) {
  _set_bit(1);
  if (targetnamespace_ == &_default_targetnamespace_) {
    targetnamespace_ = new ::std::string;
  }
  targetnamespace_->assign(value);
}
inline void IVEFSchema::set_targetnamespace(const char* value) {
  _set_bit(1);
  if (targetnamespace_ == &_default_targetnamespace_) {
    targetnamespace_ = new ::std::string;
  }
  targetnamespace_->assign(value);
}
inline ::std::string* IVEFSchema::mutable_targetnamespace() {
  _set_bit(1);
  if (targetnamespace_ == &_default_targetnamespace_) {
    targetnamespace_ = new ::std::string;
  }
  return targetnamespace_;
}

// -------------------------------------------------------------------

// IVEFHeader

// required string version = 1;
inline bool IVEFHeader::has_version() const {
  return _has_bit(0);
}
inline void IVEFHeader::clear_version() {
  if (version_ != &_default_version_) {
    version_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& IVEFHeader::version() const {
  return *version_;
}
inline void IVEFHeader::set_version(const ::std::string& value) {
  _set_bit(0);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void IVEFHeader::set_version(const char* value) {
  _set_bit(0);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline ::std::string* IVEFHeader::mutable_version() {
  _set_bit(0);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  return version_;
}

// required string msgRefId = 2;
inline bool IVEFHeader::has_msgrefid() const {
  return _has_bit(1);
}
inline void IVEFHeader::clear_msgrefid() {
  if (msgrefid_ != &_default_msgrefid_) {
    msgrefid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& IVEFHeader::msgrefid() const {
  return *msgrefid_;
}
inline void IVEFHeader::set_msgrefid(const ::std::string& value) {
  _set_bit(1);
  if (msgrefid_ == &_default_msgrefid_) {
    msgrefid_ = new ::std::string;
  }
  msgrefid_->assign(value);
}
inline void IVEFHeader::set_msgrefid(const char* value) {
  _set_bit(1);
  if (msgrefid_ == &_default_msgrefid_) {
    msgrefid_ = new ::std::string;
  }
  msgrefid_->assign(value);
}
inline ::std::string* IVEFHeader::mutable_msgrefid() {
  _set_bit(1);
  if (msgrefid_ == &_default_msgrefid_) {
    msgrefid_ = new ::std::string;
  }
  return msgrefid_;
}

// -------------------------------------------------------------------

// IVEFMSG_VesselData

// required .IVEFHeader header = 1;
inline bool IVEFMSG_VesselData::has_header() const {
  return _has_bit(0);
}
inline void IVEFMSG_VesselData::clear_header() {
  if (header_ != NULL) header_->::IVEFHeader::Clear();
  _clear_bit(0);
}
inline const ::IVEFHeader& IVEFMSG_VesselData::header() const {
  return header_ != NULL ? *header_ : *default_instance_.header_;
}
inline ::IVEFHeader* IVEFMSG_VesselData::mutable_header() {
  _set_bit(0);
  if (header_ == NULL) header_ = new ::IVEFHeader;
  return header_;
}

// required .IVEFBody body = 2;
inline bool IVEFMSG_VesselData::has_body() const {
  return _has_bit(1);
}
inline void IVEFMSG_VesselData::clear_body() {
  if (body_ != NULL) body_->::IVEFBody::Clear();
  _clear_bit(1);
}
inline const ::IVEFBody& IVEFMSG_VesselData::body() const {
  return body_ != NULL ? *body_ : *default_instance_.body_;
}
inline ::IVEFBody* IVEFMSG_VesselData::mutable_body() {
  _set_bit(1);
  if (body_ == NULL) body_ = new ::IVEFBody;
  return body_;
}

// -------------------------------------------------------------------

// IVEFBody

// repeated .IVEFVesselData vesselData = 1;
inline int IVEFBody::vesseldata_size() const {
  return vesseldata_.size();
}
inline void IVEFBody::clear_vesseldata() {
  vesseldata_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::IVEFVesselData >&
IVEFBody::vesseldata() const {
  return vesseldata_;
}
inline ::google::protobuf::RepeatedPtrField< ::IVEFVesselData >*
IVEFBody::mutable_vesseldata() {
  return &vesseldata_;
}
inline const ::IVEFVesselData& IVEFBody::vesseldata(int index) const {
  return vesseldata_.Get(index);
}
inline ::IVEFVesselData* IVEFBody::mutable_vesseldata(int index) {
  return vesseldata_.Mutable(index);
}
inline ::IVEFVesselData* IVEFBody::add_vesseldata() {
  return vesseldata_.Add();
}

// optional .IVEFLoginRequest loginRequest = 2;
inline bool IVEFBody::has_loginrequest() const {
  return _has_bit(1);
}
inline void IVEFBody::clear_loginrequest() {
  if (loginrequest_ != NULL) loginrequest_->::IVEFLoginRequest::Clear();
  _clear_bit(1);
}
inline const ::IVEFLoginRequest& IVEFBody::loginrequest() const {
  return loginrequest_ != NULL ? *loginrequest_ : *default_instance_.loginrequest_;
}
inline ::IVEFLoginRequest* IVEFBody::mutable_loginrequest() {
  _set_bit(1);
  if (loginrequest_ == NULL) loginrequest_ = new ::IVEFLoginRequest;
  return loginrequest_;
}

// optional .IVEFLoginResponse loginResponse = 3;
inline bool IVEFBody::has_loginresponse() const {
  return _has_bit(2);
}
inline void IVEFBody::clear_loginresponse() {
  if (loginresponse_ != NULL) loginresponse_->::IVEFLoginResponse::Clear();
  _clear_bit(2);
}
inline const ::IVEFLoginResponse& IVEFBody::loginresponse() const {
  return loginresponse_ != NULL ? *loginresponse_ : *default_instance_.loginresponse_;
}
inline ::IVEFLoginResponse* IVEFBody::mutable_loginresponse() {
  _set_bit(2);
  if (loginresponse_ == NULL) loginresponse_ = new ::IVEFLoginResponse;
  return loginresponse_;
}

// optional .IVEFPing ping = 4;
inline bool IVEFBody::has_ping() const {
  return _has_bit(3);
}
inline void IVEFBody::clear_ping() {
  if (ping_ != NULL) ping_->::IVEFPing::Clear();
  _clear_bit(3);
}
inline const ::IVEFPing& IVEFBody::ping() const {
  return ping_ != NULL ? *ping_ : *default_instance_.ping_;
}
inline ::IVEFPing* IVEFBody::mutable_ping() {
  _set_bit(3);
  if (ping_ == NULL) ping_ = new ::IVEFPing;
  return ping_;
}

// optional .IVEFPong pong = 5;
inline bool IVEFBody::has_pong() const {
  return _has_bit(4);
}
inline void IVEFBody::clear_pong() {
  if (pong_ != NULL) pong_->::IVEFPong::Clear();
  _clear_bit(4);
}
inline const ::IVEFPong& IVEFBody::pong() const {
  return pong_ != NULL ? *pong_ : *default_instance_.pong_;
}
inline ::IVEFPong* IVEFBody::mutable_pong() {
  _set_bit(4);
  if (pong_ == NULL) pong_ = new ::IVEFPong;
  return pong_;
}

// optional .IVEFServerStatus serverStatus = 6;
inline bool IVEFBody::has_serverstatus() const {
  return _has_bit(5);
}
inline void IVEFBody::clear_serverstatus() {
  if (serverstatus_ != NULL) serverstatus_->::IVEFServerStatus::Clear();
  _clear_bit(5);
}
inline const ::IVEFServerStatus& IVEFBody::serverstatus() const {
  return serverstatus_ != NULL ? *serverstatus_ : *default_instance_.serverstatus_;
}
inline ::IVEFServerStatus* IVEFBody::mutable_serverstatus() {
  _set_bit(5);
  if (serverstatus_ == NULL) serverstatus_ = new ::IVEFServerStatus;
  return serverstatus_;
}

// optional .IVEFLogout logout = 7;
inline bool IVEFBody::has_logout() const {
  return _has_bit(6);
}
inline void IVEFBody::clear_logout() {
  if (logout_ != NULL) logout_->::IVEFLogout::Clear();
  _clear_bit(6);
}
inline const ::IVEFLogout& IVEFBody::logout() const {
  return logout_ != NULL ? *logout_ : *default_instance_.logout_;
}
inline ::IVEFLogout* IVEFBody::mutable_logout() {
  _set_bit(6);
  if (logout_ == NULL) logout_ = new ::IVEFLogout;
  return logout_;
}

// optional .IVEFServiceRequest serviceRequest = 8;
inline bool IVEFBody::has_servicerequest() const {
  return _has_bit(7);
}
inline void IVEFBody::clear_servicerequest() {
  if (servicerequest_ != NULL) servicerequest_->::IVEFServiceRequest::Clear();
  _clear_bit(7);
}
inline const ::IVEFServiceRequest& IVEFBody::servicerequest() const {
  return servicerequest_ != NULL ? *servicerequest_ : *default_instance_.servicerequest_;
}
inline ::IVEFServiceRequest* IVEFBody::mutable_servicerequest() {
  _set_bit(7);
  if (servicerequest_ == NULL) servicerequest_ = new ::IVEFServiceRequest;
  return servicerequest_;
}

// -------------------------------------------------------------------

// IVEFVesselData

// required .IVEFPosReport posReport = 1;
inline bool IVEFVesselData::has_posreport() const {
  return _has_bit(0);
}
inline void IVEFVesselData::clear_posreport() {
  if (posreport_ != NULL) posreport_->::IVEFPosReport::Clear();
  _clear_bit(0);
}
inline const ::IVEFPosReport& IVEFVesselData::posreport() const {
  return posreport_ != NULL ? *posreport_ : *default_instance_.posreport_;
}
inline ::IVEFPosReport* IVEFVesselData::mutable_posreport() {
  _set_bit(0);
  if (posreport_ == NULL) posreport_ = new ::IVEFPosReport;
  return posreport_;
}

// repeated .IVEFStaticData staticData = 2;
inline int IVEFVesselData::staticdata_size() const {
  return staticdata_.size();
}
inline void IVEFVesselData::clear_staticdata() {
  staticdata_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::IVEFStaticData >&
IVEFVesselData::staticdata() const {
  return staticdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::IVEFStaticData >*
IVEFVesselData::mutable_staticdata() {
  return &staticdata_;
}
inline const ::IVEFStaticData& IVEFVesselData::staticdata(int index) const {
  return staticdata_.Get(index);
}
inline ::IVEFStaticData* IVEFVesselData::mutable_staticdata(int index) {
  return staticdata_.Mutable(index);
}
inline ::IVEFStaticData* IVEFVesselData::add_staticdata() {
  return staticdata_.Add();
}

// repeated .IVEFVoyage voyage = 3;
inline int IVEFVesselData::voyage_size() const {
  return voyage_.size();
}
inline void IVEFVesselData::clear_voyage() {
  voyage_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::IVEFVoyage >&
IVEFVesselData::voyage() const {
  return voyage_;
}
inline ::google::protobuf::RepeatedPtrField< ::IVEFVoyage >*
IVEFVesselData::mutable_voyage() {
  return &voyage_;
}
inline const ::IVEFVoyage& IVEFVesselData::voyage(int index) const {
  return voyage_.Get(index);
}
inline ::IVEFVoyage* IVEFVesselData::mutable_voyage(int index) {
  return voyage_.Mutable(index);
}
inline ::IVEFVoyage* IVEFVesselData::add_voyage() {
  return voyage_.Add();
}

// -------------------------------------------------------------------

// IVEFPosReport

// required .IVEFPos pos = 1;
inline bool IVEFPosReport::has_pos() const {
  return _has_bit(0);
}
inline void IVEFPosReport::clear_pos() {
  if (pos_ != NULL) pos_->::IVEFPos::Clear();
  _clear_bit(0);
}
inline const ::IVEFPos& IVEFPosReport::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_.pos_;
}
inline ::IVEFPos* IVEFPosReport::mutable_pos() {
  _set_bit(0);
  if (pos_ == NULL) pos_ = new ::IVEFPos;
  return pos_;
}

// required int32 id = 2;
inline bool IVEFPosReport::has_id() const {
  return _has_bit(1);
}
inline void IVEFPosReport::clear_id() {
  id_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 IVEFPosReport::id() const {
  return id_;
}
inline void IVEFPosReport::set_id(::google::protobuf::int32 value) {
  _set_bit(1);
  id_ = value;
}

// required int32 sourceId = 3;
inline bool IVEFPosReport::has_sourceid() const {
  return _has_bit(2);
}
inline void IVEFPosReport::clear_sourceid() {
  sourceid_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 IVEFPosReport::sourceid() const {
  return sourceid_;
}
inline void IVEFPosReport::set_sourceid(::google::protobuf::int32 value) {
  _set_bit(2);
  sourceid_ = value;
}

// required string updateTime = 4;
inline bool IVEFPosReport::has_updatetime() const {
  return _has_bit(3);
}
inline void IVEFPosReport::clear_updatetime() {
  if (updatetime_ != &_default_updatetime_) {
    updatetime_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& IVEFPosReport::updatetime() const {
  return *updatetime_;
}
inline void IVEFPosReport::set_updatetime(const ::std::string& value) {
  _set_bit(3);
  if (updatetime_ == &_default_updatetime_) {
    updatetime_ = new ::std::string;
  }
  updatetime_->assign(value);
}
inline void IVEFPosReport::set_updatetime(const char* value) {
  _set_bit(3);
  if (updatetime_ == &_default_updatetime_) {
    updatetime_ = new ::std::string;
  }
  updatetime_->assign(value);
}
inline ::std::string* IVEFPosReport::mutable_updatetime() {
  _set_bit(3);
  if (updatetime_ == &_default_updatetime_) {
    updatetime_ = new ::std::string;
  }
  return updatetime_;
}

// required float SOG = 5;
inline bool IVEFPosReport::has_sog() const {
  return _has_bit(4);
}
inline void IVEFPosReport::clear_sog() {
  sog_ = 0;
  _clear_bit(4);
}
inline float IVEFPosReport::sog() const {
  return sog_;
}
inline void IVEFPosReport::set_sog(float value) {
  _set_bit(4);
  sog_ = value;
}

// required float COG = 6;
inline bool IVEFPosReport::has_cog() const {
  return _has_bit(5);
}
inline void IVEFPosReport::clear_cog() {
  cog_ = 0;
  _clear_bit(5);
}
inline float IVEFPosReport::cog() const {
  return cog_;
}
inline void IVEFPosReport::set_cog(float value) {
  _set_bit(5);
  cog_ = value;
}

// required string lost = 7;
inline bool IVEFPosReport::has_lost() const {
  return _has_bit(6);
}
inline void IVEFPosReport::clear_lost() {
  if (lost_ != &_default_lost_) {
    lost_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& IVEFPosReport::lost() const {
  return *lost_;
}
inline void IVEFPosReport::set_lost(const ::std::string& value) {
  _set_bit(6);
  if (lost_ == &_default_lost_) {
    lost_ = new ::std::string;
  }
  lost_->assign(value);
}
inline void IVEFPosReport::set_lost(const char* value) {
  _set_bit(6);
  if (lost_ == &_default_lost_) {
    lost_ = new ::std::string;
  }
  lost_->assign(value);
}
inline ::std::string* IVEFPosReport::mutable_lost() {
  _set_bit(6);
  if (lost_ == &_default_lost_) {
    lost_ = new ::std::string;
  }
  return lost_;
}

// optional float rateOfTurn = 8;
inline bool IVEFPosReport::has_rateofturn() const {
  return _has_bit(7);
}
inline void IVEFPosReport::clear_rateofturn() {
  rateofturn_ = 0;
  _clear_bit(7);
}
inline float IVEFPosReport::rateofturn() const {
  return rateofturn_;
}
inline void IVEFPosReport::set_rateofturn(float value) {
  _set_bit(7);
  rateofturn_ = value;
}

// optional float orientation = 9;
inline bool IVEFPosReport::has_orientation() const {
  return _has_bit(8);
}
inline void IVEFPosReport::clear_orientation() {
  orientation_ = 0;
  _clear_bit(8);
}
inline float IVEFPosReport::orientation() const {
  return orientation_;
}
inline void IVEFPosReport::set_orientation(float value) {
  _set_bit(8);
  orientation_ = value;
}

// optional float length = 10;
inline bool IVEFPosReport::has_length() const {
  return _has_bit(9);
}
inline void IVEFPosReport::clear_length() {
  length_ = 0;
  _clear_bit(9);
}
inline float IVEFPosReport::length() const {
  return length_;
}
inline void IVEFPosReport::set_length(float value) {
  _set_bit(9);
  length_ = value;
}

// optional float breadth = 11;
inline bool IVEFPosReport::has_breadth() const {
  return _has_bit(10);
}
inline void IVEFPosReport::clear_breadth() {
  breadth_ = 0;
  _clear_bit(10);
}
inline float IVEFPosReport::breadth() const {
  return breadth_;
}
inline void IVEFPosReport::set_breadth(float value) {
  _set_bit(10);
  breadth_ = value;
}

// optional float altitude = 12;
inline bool IVEFPosReport::has_altitude() const {
  return _has_bit(11);
}
inline void IVEFPosReport::clear_altitude() {
  altitude_ = 0;
  _clear_bit(11);
}
inline float IVEFPosReport::altitude() const {
  return altitude_;
}
inline void IVEFPosReport::set_altitude(float value) {
  _set_bit(11);
  altitude_ = value;
}

// optional int32 navStatus = 13;
inline bool IVEFPosReport::has_navstatus() const {
  return _has_bit(12);
}
inline void IVEFPosReport::clear_navstatus() {
  navstatus_ = 0;
  _clear_bit(12);
}
inline ::google::protobuf::int32 IVEFPosReport::navstatus() const {
  return navstatus_;
}
inline void IVEFPosReport::set_navstatus(::google::protobuf::int32 value) {
  _set_bit(12);
  navstatus_ = value;
}

// optional int32 updSensorType = 14;
inline bool IVEFPosReport::has_updsensortype() const {
  return _has_bit(13);
}
inline void IVEFPosReport::clear_updsensortype() {
  updsensortype_ = 0;
  _clear_bit(13);
}
inline ::google::protobuf::int32 IVEFPosReport::updsensortype() const {
  return updsensortype_;
}
inline void IVEFPosReport::set_updsensortype(::google::protobuf::int32 value) {
  _set_bit(13);
  updsensortype_ = value;
}

// optional bool ATONOffPos = 15;
inline bool IVEFPosReport::has_atonoffpos() const {
  return _has_bit(14);
}
inline void IVEFPosReport::clear_atonoffpos() {
  atonoffpos_ = false;
  _clear_bit(14);
}
inline bool IVEFPosReport::atonoffpos() const {
  return atonoffpos_;
}
inline void IVEFPosReport::set_atonoffpos(bool value) {
  _set_bit(14);
  atonoffpos_ = value;
}

// -------------------------------------------------------------------

// IVEFStaticData

// required int32 id = 1;
inline bool IVEFStaticData::has_id() const {
  return _has_bit(0);
}
inline void IVEFStaticData::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 IVEFStaticData::id() const {
  return id_;
}
inline void IVEFStaticData::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// required string sourceName = 2;
inline bool IVEFStaticData::has_sourcename() const {
  return _has_bit(1);
}
inline void IVEFStaticData::clear_sourcename() {
  if (sourcename_ != &_default_sourcename_) {
    sourcename_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& IVEFStaticData::sourcename() const {
  return *sourcename_;
}
inline void IVEFStaticData::set_sourcename(const ::std::string& value) {
  _set_bit(1);
  if (sourcename_ == &_default_sourcename_) {
    sourcename_ = new ::std::string;
  }
  sourcename_->assign(value);
}
inline void IVEFStaticData::set_sourcename(const char* value) {
  _set_bit(1);
  if (sourcename_ == &_default_sourcename_) {
    sourcename_ = new ::std::string;
  }
  sourcename_->assign(value);
}
inline ::std::string* IVEFStaticData::mutable_sourcename() {
  _set_bit(1);
  if (sourcename_ == &_default_sourcename_) {
    sourcename_ = new ::std::string;
  }
  return sourcename_;
}

// required int32 source = 3;
inline bool IVEFStaticData::has_source() const {
  return _has_bit(2);
}
inline void IVEFStaticData::clear_source() {
  source_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 IVEFStaticData::source() const {
  return source_;
}
inline void IVEFStaticData::set_source(::google::protobuf::int32 value) {
  _set_bit(2);
  source_ = value;
}

// optional float length = 4;
inline bool IVEFStaticData::has_length() const {
  return _has_bit(3);
}
inline void IVEFStaticData::clear_length() {
  length_ = 0;
  _clear_bit(3);
}
inline float IVEFStaticData::length() const {
  return length_;
}
inline void IVEFStaticData::set_length(float value) {
  _set_bit(3);
  length_ = value;
}

// optional float breadth = 5;
inline bool IVEFStaticData::has_breadth() const {
  return _has_bit(4);
}
inline void IVEFStaticData::clear_breadth() {
  breadth_ = 0;
  _clear_bit(4);
}
inline float IVEFStaticData::breadth() const {
  return breadth_;
}
inline void IVEFStaticData::set_breadth(float value) {
  _set_bit(4);
  breadth_ = value;
}

// optional string callsign = 6;
inline bool IVEFStaticData::has_callsign() const {
  return _has_bit(5);
}
inline void IVEFStaticData::clear_callsign() {
  if (callsign_ != &_default_callsign_) {
    callsign_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& IVEFStaticData::callsign() const {
  return *callsign_;
}
inline void IVEFStaticData::set_callsign(const ::std::string& value) {
  _set_bit(5);
  if (callsign_ == &_default_callsign_) {
    callsign_ = new ::std::string;
  }
  callsign_->assign(value);
}
inline void IVEFStaticData::set_callsign(const char* value) {
  _set_bit(5);
  if (callsign_ == &_default_callsign_) {
    callsign_ = new ::std::string;
  }
  callsign_->assign(value);
}
inline ::std::string* IVEFStaticData::mutable_callsign() {
  _set_bit(5);
  if (callsign_ == &_default_callsign_) {
    callsign_ = new ::std::string;
  }
  return callsign_;
}

// optional string shipName = 7;
inline bool IVEFStaticData::has_shipname() const {
  return _has_bit(6);
}
inline void IVEFStaticData::clear_shipname() {
  if (shipname_ != &_default_shipname_) {
    shipname_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& IVEFStaticData::shipname() const {
  return *shipname_;
}
inline void IVEFStaticData::set_shipname(const ::std::string& value) {
  _set_bit(6);
  if (shipname_ == &_default_shipname_) {
    shipname_ = new ::std::string;
  }
  shipname_->assign(value);
}
inline void IVEFStaticData::set_shipname(const char* value) {
  _set_bit(6);
  if (shipname_ == &_default_shipname_) {
    shipname_ = new ::std::string;
  }
  shipname_->assign(value);
}
inline ::std::string* IVEFStaticData::mutable_shipname() {
  _set_bit(6);
  if (shipname_ == &_default_shipname_) {
    shipname_ = new ::std::string;
  }
  return shipname_;
}

// optional int32 objectType = 8;
inline bool IVEFStaticData::has_objecttype() const {
  return _has_bit(7);
}
inline void IVEFStaticData::clear_objecttype() {
  objecttype_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 IVEFStaticData::objecttype() const {
  return objecttype_;
}
inline void IVEFStaticData::set_objecttype(::google::protobuf::int32 value) {
  _set_bit(7);
  objecttype_ = value;
}

// optional int32 shipType = 9;
inline bool IVEFStaticData::has_shiptype() const {
  return _has_bit(8);
}
inline void IVEFStaticData::clear_shiptype() {
  shiptype_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 IVEFStaticData::shiptype() const {
  return shiptype_;
}
inline void IVEFStaticData::set_shiptype(::google::protobuf::int32 value) {
  _set_bit(8);
  shiptype_ = value;
}

// optional int32 IMO = 10;
inline bool IVEFStaticData::has_imo() const {
  return _has_bit(9);
}
inline void IVEFStaticData::clear_imo() {
  imo_ = 0;
  _clear_bit(9);
}
inline ::google::protobuf::int32 IVEFStaticData::imo() const {
  return imo_;
}
inline void IVEFStaticData::set_imo(::google::protobuf::int32 value) {
  _set_bit(9);
  imo_ = value;
}

// optional int32 MMSI = 11;
inline bool IVEFStaticData::has_mmsi() const {
  return _has_bit(10);
}
inline void IVEFStaticData::clear_mmsi() {
  mmsi_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 IVEFStaticData::mmsi() const {
  return mmsi_;
}
inline void IVEFStaticData::set_mmsi(::google::protobuf::int32 value) {
  _set_bit(10);
  mmsi_ = value;
}

// optional int32 ATONType = 12;
inline bool IVEFStaticData::has_atontype() const {
  return _has_bit(11);
}
inline void IVEFStaticData::clear_atontype() {
  atontype_ = 0;
  _clear_bit(11);
}
inline ::google::protobuf::int32 IVEFStaticData::atontype() const {
  return atontype_;
}
inline void IVEFStaticData::set_atontype(::google::protobuf::int32 value) {
  _set_bit(11);
  atontype_ = value;
}

// optional string ATONName = 13;
inline bool IVEFStaticData::has_atonname() const {
  return _has_bit(12);
}
inline void IVEFStaticData::clear_atonname() {
  if (atonname_ != &_default_atonname_) {
    atonname_->clear();
  }
  _clear_bit(12);
}
inline const ::std::string& IVEFStaticData::atonname() const {
  return *atonname_;
}
inline void IVEFStaticData::set_atonname(const ::std::string& value) {
  _set_bit(12);
  if (atonname_ == &_default_atonname_) {
    atonname_ = new ::std::string;
  }
  atonname_->assign(value);
}
inline void IVEFStaticData::set_atonname(const char* value) {
  _set_bit(12);
  if (atonname_ == &_default_atonname_) {
    atonname_ = new ::std::string;
  }
  atonname_->assign(value);
}
inline ::std::string* IVEFStaticData::mutable_atonname() {
  _set_bit(12);
  if (atonname_ == &_default_atonname_) {
    atonname_ = new ::std::string;
  }
  return atonname_;
}

// optional float antPosDistFromFront = 14;
inline bool IVEFStaticData::has_antposdistfromfront() const {
  return _has_bit(13);
}
inline void IVEFStaticData::clear_antposdistfromfront() {
  antposdistfromfront_ = 0;
  _clear_bit(13);
}
inline float IVEFStaticData::antposdistfromfront() const {
  return antposdistfromfront_;
}
inline void IVEFStaticData::set_antposdistfromfront(float value) {
  _set_bit(13);
  antposdistfromfront_ = value;
}

// optional float antPosDistFromLeft = 15;
inline bool IVEFStaticData::has_antposdistfromleft() const {
  return _has_bit(14);
}
inline void IVEFStaticData::clear_antposdistfromleft() {
  antposdistfromleft_ = 0;
  _clear_bit(14);
}
inline float IVEFStaticData::antposdistfromleft() const {
  return antposdistfromleft_;
}
inline void IVEFStaticData::set_antposdistfromleft(float value) {
  _set_bit(14);
  antposdistfromleft_ = value;
}

// optional string natLangShipName = 16;
inline bool IVEFStaticData::has_natlangshipname() const {
  return _has_bit(15);
}
inline void IVEFStaticData::clear_natlangshipname() {
  if (natlangshipname_ != &_default_natlangshipname_) {
    natlangshipname_->clear();
  }
  _clear_bit(15);
}
inline const ::std::string& IVEFStaticData::natlangshipname() const {
  return *natlangshipname_;
}
inline void IVEFStaticData::set_natlangshipname(const ::std::string& value) {
  _set_bit(15);
  if (natlangshipname_ == &_default_natlangshipname_) {
    natlangshipname_ = new ::std::string;
  }
  natlangshipname_->assign(value);
}
inline void IVEFStaticData::set_natlangshipname(const char* value) {
  _set_bit(15);
  if (natlangshipname_ == &_default_natlangshipname_) {
    natlangshipname_ = new ::std::string;
  }
  natlangshipname_->assign(value);
}
inline ::std::string* IVEFStaticData::mutable_natlangshipname() {
  _set_bit(15);
  if (natlangshipname_ == &_default_natlangshipname_) {
    natlangshipname_ = new ::std::string;
  }
  return natlangshipname_;
}

// optional string portOfRegistry = 17;
inline bool IVEFStaticData::has_portofregistry() const {
  return _has_bit(16);
}
inline void IVEFStaticData::clear_portofregistry() {
  if (portofregistry_ != &_default_portofregistry_) {
    portofregistry_->clear();
  }
  _clear_bit(16);
}
inline const ::std::string& IVEFStaticData::portofregistry() const {
  return *portofregistry_;
}
inline void IVEFStaticData::set_portofregistry(const ::std::string& value) {
  _set_bit(16);
  if (portofregistry_ == &_default_portofregistry_) {
    portofregistry_ = new ::std::string;
  }
  portofregistry_->assign(value);
}
inline void IVEFStaticData::set_portofregistry(const char* value) {
  _set_bit(16);
  if (portofregistry_ == &_default_portofregistry_) {
    portofregistry_ = new ::std::string;
  }
  portofregistry_->assign(value);
}
inline ::std::string* IVEFStaticData::mutable_portofregistry() {
  _set_bit(16);
  if (portofregistry_ == &_default_portofregistry_) {
    portofregistry_ = new ::std::string;
  }
  return portofregistry_;
}

// optional string countryFlag = 18;
inline bool IVEFStaticData::has_countryflag() const {
  return _has_bit(17);
}
inline void IVEFStaticData::clear_countryflag() {
  if (countryflag_ != &_default_countryflag_) {
    countryflag_->clear();
  }
  _clear_bit(17);
}
inline const ::std::string& IVEFStaticData::countryflag() const {
  return *countryflag_;
}
inline void IVEFStaticData::set_countryflag(const ::std::string& value) {
  _set_bit(17);
  if (countryflag_ == &_default_countryflag_) {
    countryflag_ = new ::std::string;
  }
  countryflag_->assign(value);
}
inline void IVEFStaticData::set_countryflag(const char* value) {
  _set_bit(17);
  if (countryflag_ == &_default_countryflag_) {
    countryflag_ = new ::std::string;
  }
  countryflag_->assign(value);
}
inline ::std::string* IVEFStaticData::mutable_countryflag() {
  _set_bit(17);
  if (countryflag_ == &_default_countryflag_) {
    countryflag_ = new ::std::string;
  }
  return countryflag_;
}

// optional float maxAirDraught = 19;
inline bool IVEFStaticData::has_maxairdraught() const {
  return _has_bit(18);
}
inline void IVEFStaticData::clear_maxairdraught() {
  maxairdraught_ = 0;
  _clear_bit(18);
}
inline float IVEFStaticData::maxairdraught() const {
  return maxairdraught_;
}
inline void IVEFStaticData::set_maxairdraught(float value) {
  _set_bit(18);
  maxairdraught_ = value;
}

// optional float maxDraught = 20;
inline bool IVEFStaticData::has_maxdraught() const {
  return _has_bit(19);
}
inline void IVEFStaticData::clear_maxdraught() {
  maxdraught_ = 0;
  _clear_bit(19);
}
inline float IVEFStaticData::maxdraught() const {
  return maxdraught_;
}
inline void IVEFStaticData::set_maxdraught(float value) {
  _set_bit(19);
  maxdraught_ = value;
}

// optional string deepWaterVesselind = 21;
inline bool IVEFStaticData::has_deepwatervesselind() const {
  return _has_bit(20);
}
inline void IVEFStaticData::clear_deepwatervesselind() {
  if (deepwatervesselind_ != &_default_deepwatervesselind_) {
    deepwatervesselind_->clear();
  }
  _clear_bit(20);
}
inline const ::std::string& IVEFStaticData::deepwatervesselind() const {
  return *deepwatervesselind_;
}
inline void IVEFStaticData::set_deepwatervesselind(const ::std::string& value) {
  _set_bit(20);
  if (deepwatervesselind_ == &_default_deepwatervesselind_) {
    deepwatervesselind_ = new ::std::string;
  }
  deepwatervesselind_->assign(value);
}
inline void IVEFStaticData::set_deepwatervesselind(const char* value) {
  _set_bit(20);
  if (deepwatervesselind_ == &_default_deepwatervesselind_) {
    deepwatervesselind_ = new ::std::string;
  }
  deepwatervesselind_->assign(value);
}
inline ::std::string* IVEFStaticData::mutable_deepwatervesselind() {
  _set_bit(20);
  if (deepwatervesselind_ == &_default_deepwatervesselind_) {
    deepwatervesselind_ = new ::std::string;
  }
  return deepwatervesselind_;
}

// -------------------------------------------------------------------

// IVEFVoyage

// required string id = 1;
inline bool IVEFVoyage::has_id() const {
  return _has_bit(0);
}
inline void IVEFVoyage::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& IVEFVoyage::id() const {
  return *id_;
}
inline void IVEFVoyage::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void IVEFVoyage::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline ::std::string* IVEFVoyage::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// required string sourceName = 2;
inline bool IVEFVoyage::has_sourcename() const {
  return _has_bit(1);
}
inline void IVEFVoyage::clear_sourcename() {
  if (sourcename_ != &_default_sourcename_) {
    sourcename_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& IVEFVoyage::sourcename() const {
  return *sourcename_;
}
inline void IVEFVoyage::set_sourcename(const ::std::string& value) {
  _set_bit(1);
  if (sourcename_ == &_default_sourcename_) {
    sourcename_ = new ::std::string;
  }
  sourcename_->assign(value);
}
inline void IVEFVoyage::set_sourcename(const char* value) {
  _set_bit(1);
  if (sourcename_ == &_default_sourcename_) {
    sourcename_ = new ::std::string;
  }
  sourcename_->assign(value);
}
inline ::std::string* IVEFVoyage::mutable_sourcename() {
  _set_bit(1);
  if (sourcename_ == &_default_sourcename_) {
    sourcename_ = new ::std::string;
  }
  return sourcename_;
}

// required int32 source = 3;
inline bool IVEFVoyage::has_source() const {
  return _has_bit(2);
}
inline void IVEFVoyage::clear_source() {
  source_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 IVEFVoyage::source() const {
  return source_;
}
inline void IVEFVoyage::set_source(::google::protobuf::int32 value) {
  _set_bit(2);
  source_ = value;
}

// optional int32 cargoType = 4;
inline bool IVEFVoyage::has_cargotype() const {
  return _has_bit(3);
}
inline void IVEFVoyage::clear_cargotype() {
  cargotype_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 IVEFVoyage::cargotype() const {
  return cargotype_;
}
inline void IVEFVoyage::set_cargotype(::google::protobuf::int32 value) {
  _set_bit(3);
  cargotype_ = value;
}

// optional string destination = 5;
inline bool IVEFVoyage::has_destination() const {
  return _has_bit(4);
}
inline void IVEFVoyage::clear_destination() {
  if (destination_ != &_default_destination_) {
    destination_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& IVEFVoyage::destination() const {
  return *destination_;
}
inline void IVEFVoyage::set_destination(const ::std::string& value) {
  _set_bit(4);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
}
inline void IVEFVoyage::set_destination(const char* value) {
  _set_bit(4);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  destination_->assign(value);
}
inline ::std::string* IVEFVoyage::mutable_destination() {
  _set_bit(4);
  if (destination_ == &_default_destination_) {
    destination_ = new ::std::string;
  }
  return destination_;
}

// optional string ETA = 6;
inline bool IVEFVoyage::has_eta() const {
  return _has_bit(5);
}
inline void IVEFVoyage::clear_eta() {
  if (eta_ != &_default_eta_) {
    eta_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& IVEFVoyage::eta() const {
  return *eta_;
}
inline void IVEFVoyage::set_eta(const ::std::string& value) {
  _set_bit(5);
  if (eta_ == &_default_eta_) {
    eta_ = new ::std::string;
  }
  eta_->assign(value);
}
inline void IVEFVoyage::set_eta(const char* value) {
  _set_bit(5);
  if (eta_ == &_default_eta_) {
    eta_ = new ::std::string;
  }
  eta_->assign(value);
}
inline ::std::string* IVEFVoyage::mutable_eta() {
  _set_bit(5);
  if (eta_ == &_default_eta_) {
    eta_ = new ::std::string;
  }
  return eta_;
}

// optional string ATA = 7;
inline bool IVEFVoyage::has_ata() const {
  return _has_bit(6);
}
inline void IVEFVoyage::clear_ata() {
  if (ata_ != &_default_ata_) {
    ata_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& IVEFVoyage::ata() const {
  return *ata_;
}
inline void IVEFVoyage::set_ata(const ::std::string& value) {
  _set_bit(6);
  if (ata_ == &_default_ata_) {
    ata_ = new ::std::string;
  }
  ata_->assign(value);
}
inline void IVEFVoyage::set_ata(const char* value) {
  _set_bit(6);
  if (ata_ == &_default_ata_) {
    ata_ = new ::std::string;
  }
  ata_->assign(value);
}
inline ::std::string* IVEFVoyage::mutable_ata() {
  _set_bit(6);
  if (ata_ == &_default_ata_) {
    ata_ = new ::std::string;
  }
  return ata_;
}

// optional float airDraught = 8;
inline bool IVEFVoyage::has_airdraught() const {
  return _has_bit(7);
}
inline void IVEFVoyage::clear_airdraught() {
  airdraught_ = 0;
  _clear_bit(7);
}
inline float IVEFVoyage::airdraught() const {
  return airdraught_;
}
inline void IVEFVoyage::set_airdraught(float value) {
  _set_bit(7);
  airdraught_ = value;
}

// optional float draught = 9;
inline bool IVEFVoyage::has_draught() const {
  return _has_bit(8);
}
inline void IVEFVoyage::clear_draught() {
  draught_ = 0;
  _clear_bit(8);
}
inline float IVEFVoyage::draught() const {
  return draught_;
}
inline void IVEFVoyage::set_draught(float value) {
  _set_bit(8);
  draught_ = value;
}

// -------------------------------------------------------------------

// IVEFMSG_LoginRequest

// required .IVEFHeader header = 1;
inline bool IVEFMSG_LoginRequest::has_header() const {
  return _has_bit(0);
}
inline void IVEFMSG_LoginRequest::clear_header() {
  if (header_ != NULL) header_->::IVEFHeader::Clear();
  _clear_bit(0);
}
inline const ::IVEFHeader& IVEFMSG_LoginRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_.header_;
}
inline ::IVEFHeader* IVEFMSG_LoginRequest::mutable_header() {
  _set_bit(0);
  if (header_ == NULL) header_ = new ::IVEFHeader;
  return header_;
}

// required .IVEFBody body = 2;
inline bool IVEFMSG_LoginRequest::has_body() const {
  return _has_bit(1);
}
inline void IVEFMSG_LoginRequest::clear_body() {
  if (body_ != NULL) body_->::IVEFBody::Clear();
  _clear_bit(1);
}
inline const ::IVEFBody& IVEFMSG_LoginRequest::body() const {
  return body_ != NULL ? *body_ : *default_instance_.body_;
}
inline ::IVEFBody* IVEFMSG_LoginRequest::mutable_body() {
  _set_bit(1);
  if (body_ == NULL) body_ = new ::IVEFBody;
  return body_;
}

// -------------------------------------------------------------------

// IVEFLoginRequest

// required string name = 1;
inline bool IVEFLoginRequest::has_name() const {
  return _has_bit(0);
}
inline void IVEFLoginRequest::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& IVEFLoginRequest::name() const {
  return *name_;
}
inline void IVEFLoginRequest::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void IVEFLoginRequest::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline ::std::string* IVEFLoginRequest::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required string password = 2;
inline bool IVEFLoginRequest::has_password() const {
  return _has_bit(1);
}
inline void IVEFLoginRequest::clear_password() {
  if (password_ != &_default_password_) {
    password_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& IVEFLoginRequest::password() const {
  return *password_;
}
inline void IVEFLoginRequest::set_password(const ::std::string& value) {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void IVEFLoginRequest::set_password(const char* value) {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline ::std::string* IVEFLoginRequest::mutable_password() {
  _set_bit(1);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  return password_;
}

// required int32 encryption = 3;
inline bool IVEFLoginRequest::has_encryption() const {
  return _has_bit(2);
}
inline void IVEFLoginRequest::clear_encryption() {
  encryption_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 IVEFLoginRequest::encryption() const {
  return encryption_;
}
inline void IVEFLoginRequest::set_encryption(::google::protobuf::int32 value) {
  _set_bit(2);
  encryption_ = value;
}

// -------------------------------------------------------------------

// IVEFMSG_LoginResponse

// required .IVEFHeader header = 1;
inline bool IVEFMSG_LoginResponse::has_header() const {
  return _has_bit(0);
}
inline void IVEFMSG_LoginResponse::clear_header() {
  if (header_ != NULL) header_->::IVEFHeader::Clear();
  _clear_bit(0);
}
inline const ::IVEFHeader& IVEFMSG_LoginResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_.header_;
}
inline ::IVEFHeader* IVEFMSG_LoginResponse::mutable_header() {
  _set_bit(0);
  if (header_ == NULL) header_ = new ::IVEFHeader;
  return header_;
}

// required .IVEFBody body = 2;
inline bool IVEFMSG_LoginResponse::has_body() const {
  return _has_bit(1);
}
inline void IVEFMSG_LoginResponse::clear_body() {
  if (body_ != NULL) body_->::IVEFBody::Clear();
  _clear_bit(1);
}
inline const ::IVEFBody& IVEFMSG_LoginResponse::body() const {
  return body_ != NULL ? *body_ : *default_instance_.body_;
}
inline ::IVEFBody* IVEFMSG_LoginResponse::mutable_body() {
  _set_bit(1);
  if (body_ == NULL) body_ = new ::IVEFBody;
  return body_;
}

// -------------------------------------------------------------------

// IVEFLoginResponse

// required string msgId = 1;
inline bool IVEFLoginResponse::has_msgid() const {
  return _has_bit(0);
}
inline void IVEFLoginResponse::clear_msgid() {
  if (msgid_ != &_default_msgid_) {
    msgid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& IVEFLoginResponse::msgid() const {
  return *msgid_;
}
inline void IVEFLoginResponse::set_msgid(const ::std::string& value) {
  _set_bit(0);
  if (msgid_ == &_default_msgid_) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline void IVEFLoginResponse::set_msgid(const char* value) {
  _set_bit(0);
  if (msgid_ == &_default_msgid_) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline ::std::string* IVEFLoginResponse::mutable_msgid() {
  _set_bit(0);
  if (msgid_ == &_default_msgid_) {
    msgid_ = new ::std::string;
  }
  return msgid_;
}

// required int32 result = 2;
inline bool IVEFLoginResponse::has_result() const {
  return _has_bit(1);
}
inline void IVEFLoginResponse::clear_result() {
  result_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 IVEFLoginResponse::result() const {
  return result_;
}
inline void IVEFLoginResponse::set_result(::google::protobuf::int32 value) {
  _set_bit(1);
  result_ = value;
}

// optional string reason = 3;
inline bool IVEFLoginResponse::has_reason() const {
  return _has_bit(2);
}
inline void IVEFLoginResponse::clear_reason() {
  if (reason_ != &_default_reason_) {
    reason_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& IVEFLoginResponse::reason() const {
  return *reason_;
}
inline void IVEFLoginResponse::set_reason(const ::std::string& value) {
  _set_bit(2);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void IVEFLoginResponse::set_reason(const char* value) {
  _set_bit(2);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline ::std::string* IVEFLoginResponse::mutable_reason() {
  _set_bit(2);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  return reason_;
}

// -------------------------------------------------------------------

// IVEFMSG_Ping

// required .IVEFHeader header = 1;
inline bool IVEFMSG_Ping::has_header() const {
  return _has_bit(0);
}
inline void IVEFMSG_Ping::clear_header() {
  if (header_ != NULL) header_->::IVEFHeader::Clear();
  _clear_bit(0);
}
inline const ::IVEFHeader& IVEFMSG_Ping::header() const {
  return header_ != NULL ? *header_ : *default_instance_.header_;
}
inline ::IVEFHeader* IVEFMSG_Ping::mutable_header() {
  _set_bit(0);
  if (header_ == NULL) header_ = new ::IVEFHeader;
  return header_;
}

// required .IVEFBody body = 2;
inline bool IVEFMSG_Ping::has_body() const {
  return _has_bit(1);
}
inline void IVEFMSG_Ping::clear_body() {
  if (body_ != NULL) body_->::IVEFBody::Clear();
  _clear_bit(1);
}
inline const ::IVEFBody& IVEFMSG_Ping::body() const {
  return body_ != NULL ? *body_ : *default_instance_.body_;
}
inline ::IVEFBody* IVEFMSG_Ping::mutable_body() {
  _set_bit(1);
  if (body_ == NULL) body_ = new ::IVEFBody;
  return body_;
}

// -------------------------------------------------------------------

// IVEFPing

// required string timeStamp = 1;
inline bool IVEFPing::has_timestamp() const {
  return _has_bit(0);
}
inline void IVEFPing::clear_timestamp() {
  if (timestamp_ != &_default_timestamp_) {
    timestamp_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& IVEFPing::timestamp() const {
  return *timestamp_;
}
inline void IVEFPing::set_timestamp(const ::std::string& value) {
  _set_bit(0);
  if (timestamp_ == &_default_timestamp_) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void IVEFPing::set_timestamp(const char* value) {
  _set_bit(0);
  if (timestamp_ == &_default_timestamp_) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline ::std::string* IVEFPing::mutable_timestamp() {
  _set_bit(0);
  if (timestamp_ == &_default_timestamp_) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}

// -------------------------------------------------------------------

// IVEFMSG_Pong

// required .IVEFHeader header = 1;
inline bool IVEFMSG_Pong::has_header() const {
  return _has_bit(0);
}
inline void IVEFMSG_Pong::clear_header() {
  if (header_ != NULL) header_->::IVEFHeader::Clear();
  _clear_bit(0);
}
inline const ::IVEFHeader& IVEFMSG_Pong::header() const {
  return header_ != NULL ? *header_ : *default_instance_.header_;
}
inline ::IVEFHeader* IVEFMSG_Pong::mutable_header() {
  _set_bit(0);
  if (header_ == NULL) header_ = new ::IVEFHeader;
  return header_;
}

// required .IVEFBody body = 2;
inline bool IVEFMSG_Pong::has_body() const {
  return _has_bit(1);
}
inline void IVEFMSG_Pong::clear_body() {
  if (body_ != NULL) body_->::IVEFBody::Clear();
  _clear_bit(1);
}
inline const ::IVEFBody& IVEFMSG_Pong::body() const {
  return body_ != NULL ? *body_ : *default_instance_.body_;
}
inline ::IVEFBody* IVEFMSG_Pong::mutable_body() {
  _set_bit(1);
  if (body_ == NULL) body_ = new ::IVEFBody;
  return body_;
}

// -------------------------------------------------------------------

// IVEFPong

// required string timeStamp = 1;
inline bool IVEFPong::has_timestamp() const {
  return _has_bit(0);
}
inline void IVEFPong::clear_timestamp() {
  if (timestamp_ != &_default_timestamp_) {
    timestamp_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& IVEFPong::timestamp() const {
  return *timestamp_;
}
inline void IVEFPong::set_timestamp(const ::std::string& value) {
  _set_bit(0);
  if (timestamp_ == &_default_timestamp_) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void IVEFPong::set_timestamp(const char* value) {
  _set_bit(0);
  if (timestamp_ == &_default_timestamp_) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline ::std::string* IVEFPong::mutable_timestamp() {
  _set_bit(0);
  if (timestamp_ == &_default_timestamp_) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}

// required string msgId = 2;
inline bool IVEFPong::has_msgid() const {
  return _has_bit(1);
}
inline void IVEFPong::clear_msgid() {
  if (msgid_ != &_default_msgid_) {
    msgid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& IVEFPong::msgid() const {
  return *msgid_;
}
inline void IVEFPong::set_msgid(const ::std::string& value) {
  _set_bit(1);
  if (msgid_ == &_default_msgid_) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline void IVEFPong::set_msgid(const char* value) {
  _set_bit(1);
  if (msgid_ == &_default_msgid_) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline ::std::string* IVEFPong::mutable_msgid() {
  _set_bit(1);
  if (msgid_ == &_default_msgid_) {
    msgid_ = new ::std::string;
  }
  return msgid_;
}

// required int32 sourceId = 3;
inline bool IVEFPong::has_sourceid() const {
  return _has_bit(2);
}
inline void IVEFPong::clear_sourceid() {
  sourceid_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 IVEFPong::sourceid() const {
  return sourceid_;
}
inline void IVEFPong::set_sourceid(::google::protobuf::int32 value) {
  _set_bit(2);
  sourceid_ = value;
}

// -------------------------------------------------------------------

// IVEFMSG_ServerStatus

// required .IVEFHeader header = 1;
inline bool IVEFMSG_ServerStatus::has_header() const {
  return _has_bit(0);
}
inline void IVEFMSG_ServerStatus::clear_header() {
  if (header_ != NULL) header_->::IVEFHeader::Clear();
  _clear_bit(0);
}
inline const ::IVEFHeader& IVEFMSG_ServerStatus::header() const {
  return header_ != NULL ? *header_ : *default_instance_.header_;
}
inline ::IVEFHeader* IVEFMSG_ServerStatus::mutable_header() {
  _set_bit(0);
  if (header_ == NULL) header_ = new ::IVEFHeader;
  return header_;
}

// required .IVEFBody body = 2;
inline bool IVEFMSG_ServerStatus::has_body() const {
  return _has_bit(1);
}
inline void IVEFMSG_ServerStatus::clear_body() {
  if (body_ != NULL) body_->::IVEFBody::Clear();
  _clear_bit(1);
}
inline const ::IVEFBody& IVEFMSG_ServerStatus::body() const {
  return body_ != NULL ? *body_ : *default_instance_.body_;
}
inline ::IVEFBody* IVEFMSG_ServerStatus::mutable_body() {
  _set_bit(1);
  if (body_ == NULL) body_ = new ::IVEFBody;
  return body_;
}

// -------------------------------------------------------------------

// IVEFServerStatus

// required string status = 1;
inline bool IVEFServerStatus::has_status() const {
  return _has_bit(0);
}
inline void IVEFServerStatus::clear_status() {
  if (status_ != &_default_status_) {
    status_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& IVEFServerStatus::status() const {
  return *status_;
}
inline void IVEFServerStatus::set_status(const ::std::string& value) {
  _set_bit(0);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void IVEFServerStatus::set_status(const char* value) {
  _set_bit(0);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline ::std::string* IVEFServerStatus::mutable_status() {
  _set_bit(0);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  return status_;
}

// optional string details = 2;
inline bool IVEFServerStatus::has_details() const {
  return _has_bit(1);
}
inline void IVEFServerStatus::clear_details() {
  if (details_ != &_default_details_) {
    details_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& IVEFServerStatus::details() const {
  return *details_;
}
inline void IVEFServerStatus::set_details(const ::std::string& value) {
  _set_bit(1);
  if (details_ == &_default_details_) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void IVEFServerStatus::set_details(const char* value) {
  _set_bit(1);
  if (details_ == &_default_details_) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline ::std::string* IVEFServerStatus::mutable_details() {
  _set_bit(1);
  if (details_ == &_default_details_) {
    details_ = new ::std::string;
  }
  return details_;
}

// -------------------------------------------------------------------

// IVEFMSG_Logout

// required .IVEFHeader header = 1;
inline bool IVEFMSG_Logout::has_header() const {
  return _has_bit(0);
}
inline void IVEFMSG_Logout::clear_header() {
  if (header_ != NULL) header_->::IVEFHeader::Clear();
  _clear_bit(0);
}
inline const ::IVEFHeader& IVEFMSG_Logout::header() const {
  return header_ != NULL ? *header_ : *default_instance_.header_;
}
inline ::IVEFHeader* IVEFMSG_Logout::mutable_header() {
  _set_bit(0);
  if (header_ == NULL) header_ = new ::IVEFHeader;
  return header_;
}

// required .IVEFBody body = 2;
inline bool IVEFMSG_Logout::has_body() const {
  return _has_bit(1);
}
inline void IVEFMSG_Logout::clear_body() {
  if (body_ != NULL) body_->::IVEFBody::Clear();
  _clear_bit(1);
}
inline const ::IVEFBody& IVEFMSG_Logout::body() const {
  return body_ != NULL ? *body_ : *default_instance_.body_;
}
inline ::IVEFBody* IVEFMSG_Logout::mutable_body() {
  _set_bit(1);
  if (body_ == NULL) body_ = new ::IVEFBody;
  return body_;
}

// -------------------------------------------------------------------

// IVEFLogout

// -------------------------------------------------------------------

// IVEFMSG_ServiceRequest

// required .IVEFHeader header = 1;
inline bool IVEFMSG_ServiceRequest::has_header() const {
  return _has_bit(0);
}
inline void IVEFMSG_ServiceRequest::clear_header() {
  if (header_ != NULL) header_->::IVEFHeader::Clear();
  _clear_bit(0);
}
inline const ::IVEFHeader& IVEFMSG_ServiceRequest::header() const {
  return header_ != NULL ? *header_ : *default_instance_.header_;
}
inline ::IVEFHeader* IVEFMSG_ServiceRequest::mutable_header() {
  _set_bit(0);
  if (header_ == NULL) header_ = new ::IVEFHeader;
  return header_;
}

// required .IVEFBody body = 2;
inline bool IVEFMSG_ServiceRequest::has_body() const {
  return _has_bit(1);
}
inline void IVEFMSG_ServiceRequest::clear_body() {
  if (body_ != NULL) body_->::IVEFBody::Clear();
  _clear_bit(1);
}
inline const ::IVEFBody& IVEFMSG_ServiceRequest::body() const {
  return body_ != NULL ? *body_ : *default_instance_.body_;
}
inline ::IVEFBody* IVEFMSG_ServiceRequest::mutable_body() {
  _set_bit(1);
  if (body_ == NULL) body_ = new ::IVEFBody;
  return body_;
}

// -------------------------------------------------------------------

// IVEFServiceRequest

// repeated .IVEFArea area = 1;
inline int IVEFServiceRequest::area_size() const {
  return area_.size();
}
inline void IVEFServiceRequest::clear_area() {
  area_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::IVEFArea >&
IVEFServiceRequest::area() const {
  return area_;
}
inline ::google::protobuf::RepeatedPtrField< ::IVEFArea >*
IVEFServiceRequest::mutable_area() {
  return &area_;
}
inline const ::IVEFArea& IVEFServiceRequest::area(int index) const {
  return area_.Get(index);
}
inline ::IVEFArea* IVEFServiceRequest::mutable_area(int index) {
  return area_.Mutable(index);
}
inline ::IVEFArea* IVEFServiceRequest::add_area() {
  return area_.Add();
}

// required .IVEFTransmission transmission = 2;
inline bool IVEFServiceRequest::has_transmission() const {
  return _has_bit(1);
}
inline void IVEFServiceRequest::clear_transmission() {
  if (transmission_ != NULL) transmission_->::IVEFTransmission::Clear();
  _clear_bit(1);
}
inline const ::IVEFTransmission& IVEFServiceRequest::transmission() const {
  return transmission_ != NULL ? *transmission_ : *default_instance_.transmission_;
}
inline ::IVEFTransmission* IVEFServiceRequest::mutable_transmission() {
  _set_bit(1);
  if (transmission_ == NULL) transmission_ = new ::IVEFTransmission;
  return transmission_;
}

// repeated .IVEFItem item = 3;
inline int IVEFServiceRequest::item_size() const {
  return item_.size();
}
inline void IVEFServiceRequest::clear_item() {
  item_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::IVEFItem >&
IVEFServiceRequest::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::IVEFItem >*
IVEFServiceRequest::mutable_item() {
  return &item_;
}
inline const ::IVEFItem& IVEFServiceRequest::item(int index) const {
  return item_.Get(index);
}
inline ::IVEFItem* IVEFServiceRequest::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::IVEFItem* IVEFServiceRequest::add_item() {
  return item_.Add();
}

// repeated .IVEFObject object = 4;
inline int IVEFServiceRequest::object_size() const {
  return object_.size();
}
inline void IVEFServiceRequest::clear_object() {
  object_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::IVEFObject >&
IVEFServiceRequest::object() const {
  return object_;
}
inline ::google::protobuf::RepeatedPtrField< ::IVEFObject >*
IVEFServiceRequest::mutable_object() {
  return &object_;
}
inline const ::IVEFObject& IVEFServiceRequest::object(int index) const {
  return object_.Get(index);
}
inline ::IVEFObject* IVEFServiceRequest::mutable_object(int index) {
  return object_.Mutable(index);
}
inline ::IVEFObject* IVEFServiceRequest::add_object() {
  return object_.Add();
}

// -------------------------------------------------------------------

// IVEFArea

// repeated .IVEFPos pos = 1;
inline int IVEFArea::pos_size() const {
  return pos_.size();
}
inline void IVEFArea::clear_pos() {
  pos_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::IVEFPos >&
IVEFArea::pos() const {
  return pos_;
}
inline ::google::protobuf::RepeatedPtrField< ::IVEFPos >*
IVEFArea::mutable_pos() {
  return &pos_;
}
inline const ::IVEFPos& IVEFArea::pos(int index) const {
  return pos_.Get(index);
}
inline ::IVEFPos* IVEFArea::mutable_pos(int index) {
  return pos_.Mutable(index);
}
inline ::IVEFPos* IVEFArea::add_pos() {
  return pos_.Add();
}

// -------------------------------------------------------------------

// IVEFTransmission

// required int32 type = 1;
inline bool IVEFTransmission::has_type() const {
  return _has_bit(0);
}
inline void IVEFTransmission::clear_type() {
  type_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 IVEFTransmission::type() const {
  return type_;
}
inline void IVEFTransmission::set_type(::google::protobuf::int32 value) {
  _set_bit(0);
  type_ = value;
}

// optional float period = 2;
inline bool IVEFTransmission::has_period() const {
  return _has_bit(1);
}
inline void IVEFTransmission::clear_period() {
  period_ = 0;
  _clear_bit(1);
}
inline float IVEFTransmission::period() const {
  return period_;
}
inline void IVEFTransmission::set_period(float value) {
  _set_bit(1);
  period_ = value;
}

// -------------------------------------------------------------------

// IVEFItem

// required int32 element = 1;
inline bool IVEFItem::has_element() const {
  return _has_bit(0);
}
inline void IVEFItem::clear_element() {
  element_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 IVEFItem::element() const {
  return element_;
}
inline void IVEFItem::set_element(::google::protobuf::int32 value) {
  _set_bit(0);
  element_ = value;
}

// required string field = 2;
inline bool IVEFItem::has_field() const {
  return _has_bit(1);
}
inline void IVEFItem::clear_field() {
  if (field_ != &_default_field_) {
    field_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& IVEFItem::field() const {
  return *field_;
}
inline void IVEFItem::set_field(const ::std::string& value) {
  _set_bit(1);
  if (field_ == &_default_field_) {
    field_ = new ::std::string;
  }
  field_->assign(value);
}
inline void IVEFItem::set_field(const char* value) {
  _set_bit(1);
  if (field_ == &_default_field_) {
    field_ = new ::std::string;
  }
  field_->assign(value);
}
inline ::std::string* IVEFItem::mutable_field() {
  _set_bit(1);
  if (field_ == &_default_field_) {
    field_ = new ::std::string;
  }
  return field_;
}

// -------------------------------------------------------------------

// IVEFObject

// required string fileName = 1;
inline bool IVEFObject::has_filename() const {
  return _has_bit(0);
}
inline void IVEFObject::clear_filename() {
  if (filename_ != &_default_filename_) {
    filename_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& IVEFObject::filename() const {
  return *filename_;
}
inline void IVEFObject::set_filename(const ::std::string& value) {
  _set_bit(0);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void IVEFObject::set_filename(const char* value) {
  _set_bit(0);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline ::std::string* IVEFObject::mutable_filename() {
  _set_bit(0);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  return filename_;
}

// -------------------------------------------------------------------

// IVEFPos

// required float lat = 1;
inline bool IVEFPos::has_lat() const {
  return _has_bit(0);
}
inline void IVEFPos::clear_lat() {
  lat_ = 0;
  _clear_bit(0);
}
inline float IVEFPos::lat() const {
  return lat_;
}
inline void IVEFPos::set_lat(float value) {
  _set_bit(0);
  lat_ = value;
}

// required float long = 2;
inline bool IVEFPos::has_long_() const {
  return _has_bit(1);
}
inline void IVEFPos::clear_long_() {
  long__ = 0;
  _clear_bit(1);
}
inline float IVEFPos::long_() const {
  return long__;
}
inline void IVEFPos::set_long_(float value) {
  _set_bit(1);
  long__ = value;
}

#endif  // PROTOBUF_IVEF_2eproto__INCLUDED
